(S'3d56a71dc0866a45e6458630cbacb4f0'
p1
(ihappydoclib.parseinfo.moduleinfo
ModuleInfo
p2
(dp3
S'_namespaces'
p4
((dp5
(dp6
tp7
sS'_import_info'
p8
(ihappydoclib.parseinfo.imports
ImportInfo
p9
(dp10
S'_named_imports'
p11
(dp12
sS'_straight_imports'
p13
(lp14
sbsS'_filename'
p15
S'../python/frowns/extensions/vflib/NetworkGraph/__init__.py'
p16
sS'_docstring'
p17
S'"""User Documentation\n\n A graph holds a collection of nodes and edges.  Each node\n must be derived from Graph.GraphNode and each edge must\n be derived from Graph.GraphEdge.\n\n You can see example classes in Node.py and Edge.py tailored\n for network topology.\n\nI Implementation details that you don\'t really need to know about\n Why use handles?\n \n Each node and edge has a unique integer identifier known as\n a handle.  The handle is used to help identify a particular\n object or instance of an object.  For example two different\n nodes may be equivalent but are not the same object.  These\n two nodes will have different handles.\n\n The handles are used to create the internal graph structure.\n\n For example a node N might have a handle of 1\n >>> from NetworkGraph.GraphObject import GraphObject\n >>> N = GraphObject()\n >>> print N.handle\n 1\n\n and a node M might have a handle of 2\n >>> M = GraphObject()\n >>> print M.handle\n 2\n\n the nodes might be equivalent\n >>> print N == M\n 1\n\n but they are not the same\n >>> print N is M\n 0\n\n >>> print N.handle == M.handle\n 0\n\n Using an integer handle helps speed up dictionary lookups inside\n the graph class.  Technically they aren\'t really necessary but\n they speed things up by an order of magnitude.\n\n\nII Creating a graph\n  >>> from NetworkGraph.Graph import Graph\n  >>> g = Graph()\n\n  We have just created a graph with no edges or nodes.\n  We need to create a node now.\n  >>> from NetworkGraph.GraphObject import GraphNode\n  >>> node1 = GraphNode()\n\n  This creates an unlabeled node.  To create a labeled\n  node:\n  >>> node2 = GraphNode(label="blue")\n\n  The label can be any python object that can be used in an\n  equivelence statement.\n\n  >>> print node1 == node2\n  0\n\n  We can now add the nodes to the graph.\n  >>> g.add_node(node1)\n  >>> g.add_node(node2)\n\n  Check to see if the graph contains node1?\n  >>> print g.has_node(node1)\n  1\n\n  We can add an edge between node1 and node2\n\n  >>> from NetworkGraph.GraphObject import GraphEdge\n  >>> edge1 = GraphEdge(label="my dog has fleas")\n  >>> g.add_edge(edge1, node1, node2)\n  >>> print g.has_edge(edge1)\n  1\n\n  We can query edges and nodes about their topology\n  >>> print edge1.nodes\n  (GraphNode(), GraphNode(\'blue\'))\n\n  Let\'s find the node on the other end of edge1 from node1\n  >>> n = edge1.xnode(node1)\n  This better be node2 :)  Notice we are not using == here since\n  we are checking to see if n is the same object as node2.\n  >>> print n is node2\n  1\n\n  We could have used handles as well\n  >>> print n.handle == node2.handle\n  1\n\n  Let\'s dump the topology\n  >>> g.dump()\n  Topology\n  Nodes\n\tGraphNode()\n\tGraphNode(`blue`)\n\n  Edges\n\tGraphEdge(`my dog has fleas`) (GraphNode(), GraphNode(`blue`))\n  \n  For fun let\'s remove an edge\n  >>> g.remove_edge(edge1)\n  >>> g.dump()\n  Topology\n  Nodes\n\tGraphNode()\n\tGraphNode(\'blue\')\n\n  Edges\n\n  Now let\'s add it back\n  >>> g.add_edge(edge1, node1, node2)\n\n  We can\'t add the same edge twice\n  >>> g.add_edge(edge1, node1, node2)\n  Traceback (most recent call last):\n  File "<stdin>", line 1, in ?\n  File "GraphObject.py", line 20, in set_parent\n    assert self.parent is None, "%s already belongs to a graph!"\n  AssertionError: GraphEdge already belongs to a graph!\n\n  \nIII\n  Using graphs.\n\n  This package uses three types of graphs, Graph\'s, matchable graphs\n  and matching graphs.\n  \n  The matchable and matching graphs are python objects created for\n  the sole purpose of subgraph isomorphisms.  They are created from Graph\n  objects in the following manner:\n\n  matchableGraph = graph.to_graph()\n  matcher = graph.to_matcher()\n\n  a matcher has two methods that both operate on matchable graphs.\n\n  results = matcher.match(matchableGraph, limit=-1)\n    The match function returns up to limit matches of the\n    matcher topology on the matchableGraph topology.\n    This returns all matches found in all permutations.\n    \n    \n  results = matcher.umatch(matchableGraph, limit=-1)\n    The match function returns up to limit matches of the\n    matcher topology on the matchableGraph topology.\n    This returns all the unique matches on a graph.\n    Permutations of the same match are not returned.\n\n\n  The results list is a list of nodes and edges found in the\n  isomorphism.\n\n  Let\'s try matching g against itself.\n  First create a matchable object.\n  >>> h = g.to_graph()\n\n  Now create a matcher\n  >>> matcher = g.to_matcher()\n\n  >>> results = matcher.match(h)\n  >>> for nodes, edges in results:\n  >>>     print nodes\n  >>>     print edges\n  (GraphNode(), GraphNode(\'blue\'))\n  (GraphEdge(\'my dog has fleas\'),)\n\n  Let\'s check this a little better and make a clone of g, add\n  a node to the clone and see what matches.  But first, what\n  is a clone?\n\n  >>> clone = g.clone()\n\n  Clone\'s contain the exact topology of their parent but have\n  completely different internal nodes and objects.\n\n  The following code loops through all the nodes in g\n  and makes sure that they don\'t exist in the clone.\n\n  >>> for node in g.nodes:\n  >>>     assert not clone.has_node(node)\n\n  However the same node in g should be equivalent to the same\n  node in the clone (we\'ll use the handy python zip function\n  to zip two lists together)\n\n  >>> for original, cloned in zip(g.nodes, clone.nodes):\n  >>>   assert original == cloned\n  >>>   assert original is not cloned\n\n  I\'m beating this point to death to point out the fact that\n  these are different graphs.  Matching results from a parent\n  graph are not transferable to the clone graph.  The clone\n  needs to be rematched.\n  \n  \n  Okay, we\'ve made a clone so let\'s add an edge and node to the clone.\n  >>> node3 = GraphNode("I am a clone!")\n  >>> edge2 = GraphEdge("new edge")\n  >>> clone.add_node(node3)\n\n  We need to get the clone\'s first node here since node1\n  doesn\'t exist in the clone\n  >>> n1 = clone.nodes[0]\n  >>> clone.add_edge(edge2, node3, n1)\n\n  We\'ll use the original matcher to match the original graph\n  against the modified clone\n  >>> matchableClone = clone.to_graph()\n  >>> results = matcher.umatch(matchableClone)\n  \n  Now let\'s make a new graph with all of the matching nodes\n  and edges removed\n\n  >>> nodes, edges = results[0]\n  >>> partialClone = clone.clone(ignoreNodes=nodes, ignoreEdges=edges)\n\n  Notice how the partialClone only has the node we added.  Since\n  all other nodes matched, they were removed.\n  >>> partialClone.dump()\n  Topology\n  Nodes\n       GraphNode(\'I am a clone!\')\n\n  Edges\n\nIV\n Graph storage.  Matcher graphs and matchable graphs are not natively\n storable.  This is partly because they hold arbitrary python objects\n and code and partly because they are actually C++ objects that\n are wrapping this codebase.\n\n Graph objects however, are very storable using python\'s serialization\n module pickle.\n\n >>> import pickle\n >>> file = open("graphfile", "wb")\n >>> pickle.dump(clone, file)\n\n Perhaps a nicer mechanism is using shelve.  Shelve works quite\n nice if you have a real database installed.  See the shelve\n module or python documentation for details.  Shelve database\n behave like python dictionaries but can store picklable objects. \n\n >>> import shelve\n >>> db = shelve.open("foo.database")\n >>> db[\'first graph\'] = clone\n >>> db.close()\n \n >>> import shelve\n >>> db = shelve.open("foo.database")\n >>> graph = db[\'first graph\']\n\n The berkeley database is particularly good for large objects.\n See pybsddb3.sourceforge.net for downloads.  You\'ll have to\n replace import shelve with something like\n >>> import bsddb3.dbshelve as shelve\n\n When loading shelve or pickle solutions it is a good idea to\n replace each graph with it\'s clone to reset the handles since\n they are not saved from one session to another.  In a future\n version this should not be necessary.\n\n >>> graph = graph.clone()\n """'
p18
sS'_name'
p19
S'__init__'
p20
sS'_parent'
p21
NsS'_comment_info'
p22
(dp23
sS'_configuration_values'
p24
(dp25
S'include_comments'
p26
I1
sS'cacheFilePrefix'
p27
S'.happydoc.'
p28
sS'useCache'
p29
I1
sS'docStringFormat'
p30
S'StructuredText'
p31
ssS'_class_info'
p32
g5
sS'_function_info'
p33
g6
sS'_comments'
p34
S''
sbt.