(S'f0275ec9d3393a1df9b7d78914417933'
p1
(ihappydoclib.parseinfo.moduleinfo
ModuleInfo
p2
(dp3
S'_namespaces'
p4
((dp5
S'SplitFingerprint'
p6
(ihappydoclib.parseinfo.classinfo
ClassInfo
p7
(dp8
g4
((dp9
(dp10
S'addPath'
p11
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
p12
(dp13
g4
((dp14
(dp15
tp16
sS'_exception_info'
p17
(dp18
sS'_parameter_names'
p19
(S'self'
p20
S'length'
p21
S'path'
p22
tp23
sS'_parameter_info'
p24
(dp25
g22
(NNNtp26
sg20
(NNNtp27
sg21
(NNNtp28
ssS'_filename'
p29
S'../python/frowns/Fingerprint/Fingerprint.py'
p30
sS'_docstring'
p31
S''
sS'_name'
p32
g11
sS'_parent'
p33
g7
sS'_comment_info'
p34
(dp35
(S'Fingerprint'
tp36
S' We also need a good way to cache these to disk.  I suppose\n cPickle will work just fine for now...\n'
p37
ssS'_configuration_values'
p38
(dp39
sS'_class_info'
p40
g14
sS'_function_info'
p41
g15
sS'_comments'
p42
S''
sbsS'to_list'
p43
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
p44
(dp45
g4
((dp46
(dp47
tp48
sg17
(dp49
sg19
(S'self'
p50
tp51
sg24
(dp52
g50
(NNNtp53
ssg29
g30
sg31
S''
sg32
g43
sg33
g7
sg34
g35
sg38
(dp54
sg40
g46
sg41
g47
sg42
S''
sbsS'__init__'
p55
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
p56
(dp57
g4
((dp58
(dp59
tp60
sg17
(dp61
sg19
(S'self'
p62
S'maxdepth'
p63
S'integersPerPrint'
p64
tp65
sg24
(dp66
g62
(NNNtp67
sg63
(I1
S'7'
Ntp68
sg64
(I1
S'[ 4 ] * 6'
Ntp69
ssg29
g30
sg31
S''
sg32
g55
sg33
g7
sg34
g35
sg38
(dp70
sg40
g58
sg41
g59
sg42
S''
sbsS'__contains__'
p71
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
p72
(dp73
g4
((dp74
(dp75
tp76
sg17
(dp77
sg19
(S'self'
p78
S'other'
p79
tp80
sg24
(dp81
g78
(NNNtp82
sg79
(NNNtp83
ssg29
g30
sg31
S''
sg32
g71
sg33
g7
sg34
g35
sg38
(dp84
sg40
g74
sg41
g75
sg42
S''
sbstp85
sg29
g30
sg31
S''
sS'_class_member_info'
p86
(lp87
sg32
g6
sg33
g2
sg34
g35
sS'_base_class_info'
p88
(lp89
sg38
(dp90
sg40
g9
sg41
g10
sg42
S''
sbsS'Fingerprint'
p91
(ihappydoclib.parseinfo.classinfo
ClassInfo
p92
(dp93
g4
((dp94
(dp95
S'to_list'
p96
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
p97
(dp98
g4
((dp99
(dp100
tp101
sg17
(dp102
sg19
(S'self'
p103
tp104
sg24
(dp105
g103
(NNNtp106
ssg29
g30
sg31
S''
sg32
g96
sg33
g92
sg34
g35
sg38
(dp107
sg40
g99
sg41
g100
sg42
S''
sbsS'addPath'
p108
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
p109
(dp110
g4
((dp111
(dp112
tp113
sg17
(dp114
sg19
(S'self'
p115
S'path'
p116
tp117
sg24
(dp118
g116
(NNNtp119
sg115
(NNNtp120
ssg29
g30
sg31
S''
sg32
g108
sg33
g92
sg34
g35
sg38
(dp121
sg40
g111
sg41
g112
sg42
S''
sbsS'intTobitlist'
p122
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
p123
(dp124
g4
((dp125
(dp126
tp127
sg17
(dp128
sg19
(S'self'
p129
S'i'
tp130
sg24
(dp131
S'i'
(NNNtp132
sg129
(NNNtp133
ssg29
g30
sg31
S''
sg32
g122
sg33
g92
sg34
g35
sg38
(dp134
sg40
g125
sg41
g126
sg42
S''
sbsS'__init__'
p135
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
p136
(dp137
g4
((dp138
(dp139
tp140
sg17
(dp141
sg19
(S'self'
p142
S'numIntegers'
p143
S'fingerprint'
p144
tp145
sg24
(dp146
g142
(NNNtp147
sg143
(I1
S'1'
Ntp148
sg144
(I1
S'None'
Ntp149
ssg29
g30
sg31
S''
sg32
g135
sg33
g92
sg34
g35
sg38
(dp150
sg40
g138
sg41
g139
sg42
S''
sbsS'__contains__'
p151
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
p152
(dp153
g4
((dp154
(dp155
tp156
sg17
(dp157
S'"Fingerprints not the same size!"'
p158
Nssg19
(S'self'
p159
S'other'
p160
tp161
sg24
(dp162
g159
(NNNtp163
sg160
(NNNtp164
ssg29
g30
sg31
S''
sg32
g151
sg33
g92
sg34
g35
sg38
(dp165
sg40
g154
sg41
g155
sg42
S''
sbstp166
sg29
g30
sg31
S''
sg86
(lp167
sg32
g91
sg33
g2
sg34
g35
sg88
(lp168
sg38
(dp169
sg40
g94
sg41
g95
sg42
g37
sbs(dp170
S'test'
p171
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
p172
(dp173
g4
((dp174
(dp175
tp176
sg17
(dp177
sg19
(tsg24
(dp178
sg29
g30
sg31
S''
sg32
g171
sg33
g2
sg34
g35
sg38
(dp179
sg40
g174
sg41
g175
sg42
S''
sbstp180
sS'_import_info'
p181
(ihappydoclib.parseinfo.imports
ImportInfo
p182
(dp183
S'_named_imports'
p184
(dp185
sS'_straight_imports'
p186
(lp187
S'random'
p188
aS'sys'
p189
asbsg29
g30
sg31
S'"""Fingerprint\n generate fingerprints from molecules.\n\n fp = Fingerprint(numIntegers)\n   Generate a fingerprint object that stores fingerprints\n   in an array of numIntegers.\n\n fp.addPath(path)\n   add a path to the fingerprint.  path is any str\'able\n   value.\n\n fp in fp2\n   returns 1 if the fingerprint fp is a contained in the fingerprint\n   fp2.\n\n   This might be a bastardazation of __contains__ but I sort\n   of like it.\n   \n The method for creating fingerprints is remarkably simple.\n\n a sequence of non branching paths is extracted from a molecule.\n A path is a string value named atoms and named bonds\n through the traversal.  For instance:\n \'C-C-C-C-N\' or even \'Carbon through single bond to Carbon\'.\n Any string will do as long as the string is always the\n same for the same path through the same or other molecules.\n\n For each path\n  1 convert the string to an integer value and use it to\n    seed a random number generator\n    (random.seed can use any hashable value as the seed!\n     python, again, is cool!)\n    random.seed(path)\n  2 pull out two random integers from the seeded generator\n    index = int(random.random() * NUM_INTS)\n    bit   = int(random.random() * INT_SIZE)\n\n  fingerprint[index] = fingerprint[index] | 1<<bit\n\n we store a fingerprint as an array of integers.  Each integer\n has a certain number of bits that can be flipped.  The process\n of adding a path to a fingerprint is simply choosing the index\n and bit position for a path.  The above procedure does this\n in a deterministic fashion.\n"""'
p190
sg32
S'Fingerprint'
p191
sg33
Nsg34
g35
sg38
(dp192
S'include_comments'
p193
I1
sS'cacheFilePrefix'
p194
S'.happydoc.'
p195
sS'useCache'
p196
I1
sS'docStringFormat'
p197
S'StructuredText'
p198
ssg40
g5
sg41
g170
sg42
S''
sbt.