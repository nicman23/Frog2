(S'e4d4cd6fea614e9727ae937d6a1b0e13'
p1
(ihappydoclib.parseinfo.moduleinfo
ModuleInfo
p2
(dp3
S'_namespaces'
p4
((dp5
S'Fusion'
p6
(ihappydoclib.parseinfo.classinfo
ClassInfo
p7
(dp8
g4
((dp9
(dp10
S'updatePath'
p11
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
p12
(dp13
g4
((dp14
(dp15
tp16
sS'_exception_info'
p17
(dp18
sS'_parameter_names'
p19
(S'self'
p20
S'newpath'
p21
S'ring'
p22
tp23
sS'_parameter_info'
p24
(dp25
g21
(NNNtp26
sg20
(NNNtp27
sg22
(NNNtp28
ssS'_filename'
p29
S'../python/frowns/perception/RingDetection.py'
p30
sS'_docstring'
p31
S''
sS'_name'
p32
g11
sS'_parent'
p33
g7
sS'_comment_info'
p34
(dp35
(S'_recurseMarkRingAtomsAndBonds'
tp36
S'  Mark all the atoms and bonds that are in rings\n'
p37
s(S'Fusion'
tp38
S'  Now we have to remove all large rings that completely\n  contain smaller rings\n'
p39
s(S'Span'
tp40
S'  Finds all linear paths from a root atom to all other atoms\n   This is the time consuming part\n'
p41
s(S'gotOne'
tp42
S'  From a given root bond make all the spans from its atoms\n   then recombine them to form rings\n'
p43
ssS'_configuration_values'
p44
(dp45
sS'_class_info'
p46
g14
sS'_function_info'
p47
g15
sS'_comments'
p48
S''
sbsS'__init__'
p49
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
p50
(dp51
g4
((dp52
(dp53
tp54
sg17
(dp55
sg19
(S'self'
p56
S'path'
p57
S'rings'
p58
tp59
sg24
(dp60
g57
(NNNtp61
sg56
(NNNtp62
sg58
(NNNtp63
ssg29
g30
sg31
S''
sg32
g49
sg33
g7
sg34
g35
sg44
(dp64
sg46
g52
sg47
g53
sg48
S''
sbstp65
sg29
g30
sg31
S''
sS'_class_member_info'
p66
(lp67
sg32
g6
sg33
g2
sg34
g35
sS'_base_class_info'
p68
(lp69
sg44
(dp70
sg46
g9
sg47
g10
sg48
g39
sbsS'Span'
p71
(ihappydoclib.parseinfo.classinfo
ClassInfo
p72
(dp73
g4
((dp74
(dp75
S'update'
p76
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
p77
(dp78
g4
((dp79
(dp80
tp81
sg17
(dp82
sg19
(S'self'
p83
S'path'
p84
tp85
sg24
(dp86
g84
(NNNtp87
sg83
(NNNtp88
ssg29
g30
sg31
S''
sg32
g76
sg33
g72
sg34
g35
sg44
(dp89
sg46
g79
sg47
g80
sg48
S''
sbsS'__init__'
p90
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
p91
(dp92
g4
((dp93
(dp94
tp95
sg17
(dp96
sg19
(S'self'
p97
S'atom'
p98
S'parent'
p99
tp100
sg24
(dp101
g97
(NNNtp102
sg99
(I1
S'None'
Ntp103
sg98
(NNNtp104
ssg29
g30
sg31
S''
sg32
g90
sg33
g72
sg34
g35
sg44
(dp105
sg46
g93
sg47
g94
sg48
S''
sbsS'__repr__'
p106
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
p107
(dp108
g4
((dp109
(dp110
tp111
sg17
(dp112
sg19
(S'self'
p113
tp114
sg24
(dp115
g113
(NNNtp116
ssg29
g30
sg31
S''
sg32
g106
sg33
g72
sg34
g35
sg44
(dp117
sg46
g109
sg47
g110
sg48
S''
sbstp118
sg29
g30
sg31
S'A span is really a path back to a central atom.  Consider it\n    a type of linked list that can compute a linear path from\n    an atom to a root atom.\n\n    span = Span(atom, parent)\n    path = []\n    span.update(path)\n    makes path a linear path from span.atom to the root span\n    '
p119
sg66
(lp120
sg32
g71
sg33
g2
sg34
g35
sg68
(lp121
sg44
(dp122
sg46
g74
sg47
g75
sg48
g41
sbs(dp123
S'gotOne'
p124
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
p125
(dp126
g4
((dp127
(dp128
tp129
sg17
(dp130
sg19
(S'lring'
p131
S'rring'
p132
S'sets'
p133
tp134
sg24
(dp135
g132
(NNNtp136
sg133
(NNNtp137
sg131
(NNNtp138
ssg29
g30
sg31
S'(ring, sets)->add ring to the sets dictionary'
p139
sg32
g124
sg33
g2
sg34
g35
sg44
(dp140
sg46
g127
sg47
g128
sg48
g43
sbsS'getRing'
p141
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
p142
(dp143
g4
((dp144
(dp145
tp146
sg17
(dp147
sg19
(S'graph'
p148
S'bond'
p149
S'sets'
p150
tp151
sg24
(dp152
g148
(NNNtp153
sg150
(NNNtp154
sg149
(NNNtp155
ssg29
g30
sg31
S'(graph, bond, sets)->find all rings starting from bond and\n    add them to the sets member'
p156
sg32
g141
sg33
g2
sg34
g35
sg44
(dp157
sg46
g144
sg47
g145
sg48
S''
sbsS'sssr_no_closures'
p158
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
p159
(dp160
g4
((dp161
(dp162
tp163
sg17
(dp164
sg19
(S'graph'
p165
tp166
sg24
(dp167
g165
(NNNtp168
ssg29
g30
sg31
S''
sg32
g158
sg33
g2
sg34
g35
sg44
(dp169
sg46
g161
sg47
g162
sg48
S''
sbsS'markRingAtomsAndBonds'
p170
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
p171
(dp172
g4
((dp173
(dp174
tp175
sg17
(dp176
sg19
(S'graph'
p177
tp178
sg24
(dp179
g177
(NNNtp180
ssg29
g30
sg31
S'(graph)->mark all the atoms that can possibly be in a ring\n    system.  These are marked with atom._inring = 1 and bond._inring = 1\n    otherwise atom._inring = 0 and bond._inring  = 0'
p181
sg32
g170
sg33
g2
sg34
g35
sg44
(dp182
sg46
g173
sg47
g174
sg48
S''
sbsS'breadthFirstSpans'
p183
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
p184
(dp185
g4
((dp186
(dp187
tp188
sg17
(dp189
sg19
(S'root'
p190
S'spans'
p191
S'visited'
p192
S'maxDepth'
p193
tp194
sg24
(dp195
g192
(NNNtp196
sg190
(NNNtp197
sg193
(I1
S'20'
Ntp198
sg191
(NNNtp199
ssg29
g30
sg31
S"(atom, spans, visited, maxDepth=20)->generate the breadthFirst spans\n    eminating from atom to all other accessible atoms.\n    spans must be a list of None's equal to the number of atoms\n    in the molecule so that spans[atom.index] should indicate a\n    particular atom's span to the root\n\n    The maxDepth flag is fairly important, but we're dealing with\n    small molecules here right?  You can always set this to\n    the number of atoms in the molecule for a complete solution.\n    "
p200
sg32
g183
sg33
g2
sg34
g35
sg44
(dp201
sg46
g186
sg47
g187
sg48
S''
sbsS'_recurseMarkRingAtomsAndBonds'
p202
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
p203
(dp204
g4
((dp205
(dp206
tp207
sg17
(dp208
sg19
(S'graph'
p209
S'atom'
p210
S'atomsVisited'
p211
S'bondsVisited'
p212
S'path'
p213
tp214
sg24
(dp215
g211
(NNNtp216
sg209
(NNNtp217
sg213
(NNNtp218
sg212
(NNNtp219
sg210
(NNNtp220
ssg29
g30
sg31
S''
sg32
g202
sg33
g2
sg34
g35
sg44
(dp221
sg46
g205
sg47
g206
sg48
g37
sbsS'uniqueifyRings'
p222
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
p223
(dp224
g4
((dp225
(dp226
tp227
sg17
(dp228
sg19
(S'sets'
p229
S'numRings'
p230
tp231
sg24
(dp232
g230
(NNNtp233
sg229
(NNNtp234
ssg29
g30
sg31
S''
sg32
g222
sg33
g2
sg34
g35
sg44
(dp235
sg46
g225
sg47
g226
sg48
S''
sbsS'sssr'
p236
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
p237
(dp238
g4
((dp239
(dp240
tp241
sg17
(dp242
sg19
(S'graph'
p243
S'closuresMarked'
p244
tp245
sg24
(dp246
g244
(I1
S'1'
Ntp247
sg243
(NNNtp248
ssg29
g30
sg31
S'(molecule, closuresMarked=1) -> determine the sssr (smallest set of smallest rings) for a graph\n    if closuresMarked is set then it is assumed that bonds used in closures\n    are marked with an attribute _closure'
p249
sg32
g236
sg33
g2
sg34
g35
sg44
(dp250
sg46
g239
sg47
g240
sg48
S''
sbsS'getBondsInOrder'
p251
(ihappydoclib.parseinfo.functioninfo
FunctionInfo
p252
(dp253
g4
((dp254
(dp255
tp256
sg17
(dp257
sg19
(S'atoms'
p258
tp259
sg24
(dp260
g258
(NNNtp261
ssg29
g30
sg31
S''
sg32
g251
sg33
g2
sg34
g35
sg44
(dp262
sg46
g254
sg47
g255
sg48
S''
sbstp263
sS'_import_info'
p264
(ihappydoclib.parseinfo.imports
ImportInfo
p265
(dp266
S'_named_imports'
p267
(dp268
S'frerejaque'
p269
(lp270
S'frerejaqueNumber'
p271
asS'frowns'
p272
(lp273
S'Cycle'
p274
assS'_straight_imports'
p275
(lp276
sbsg29
g30
sg31
S'"""\nSmallest set of smallest rings detection code inspired by\nPat Walter\'s and Matt Stahl\'s Babel rings.c with plenty of\nchanges!\n\nI don\'t like it very much but it appears to work all right.\n\nFigueras is slightly faster but has some problems.\nThis implementation forms a spanning tree up to a given depth\n(20) which means that 40+ atom rings might not be found\ncorrectly.  see maxDepth below.\n\nimplementation Notes:\n This could be sped up slightly by making a class based\n  object out of it.\n\n The one problem you may run into is the bond._closure property\n  that may or may not be defined.  Essentially this indicates\n  whether a bond was used as a closure bond.  This ring detection\n  algorithm can leverage off the smiles parser to start ring\n  searches only from closure bonds.\n\n  It\'s kind of ugly and won\'t work with standard daylight\n  molecules because they don\'t have this property\n\n  But my guess is look at GraphGenerator and somewhere just set\n  closureBond._closure = 1\n\n\n BUGS:\n The following code won\'t work directly on daylight (PyDaylight)\n molecules yet for the following reasons.\n \n   atom.index needs to be the atom\'s index into mol.atoms\n   bond.index needs to be the bond\'s index into mol.bonds\n   atom._inring is used to indicate whether an atom is\n                in a ring\n   bond._inring is used to indicate whether an bond is\n                in a ring\n\n   bond._closure optionally indicates whether the bond was\n     used in the parsing routine as a closure.  This can\n     reduce the number of atoms searched as ring starts.\n\n   These data place holders will be refactored in a future\n   version of this code for better (and easier) checking\n   against daylight molecules.  That is, it would be nice\n   if you could use either a daylight or one of our own\n   molecules for testing purposes.  Although we still\n   have to worry about what to do with the ring information\n   for the daylight molecule case...\n                \n\nThe license for the rings.c was use at your own risk and\nas-is.  I guess that applies here :)\n"""'
p277
sg32
S'RingDetection'
p278
sg33
Nsg34
g35
sg44
(dp279
S'include_comments'
p280
I1
sS'cacheFilePrefix'
p281
S'.happydoc.'
p282
sS'useCache'
p283
I1
sS'docStringFormat'
p284
S'StructuredText'
p285
ssg46
g5
sg47
g123
sg48
S''
sbt.